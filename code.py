# -*- coding: utf-8 -*-
"""glowny.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rCsQb9oYg3aIWbKNlssNuaMQDSJh-NsI
"""

import pandas as pd
import openpyxl as pyx
from sklearn.linear_model import LinearRegression
from scipy.stats import f_oneway
import statsmodels.api as sm
import numpy as np
from sklearn.metrics import r2_score
import matplotlib.pyplot as plt
import seaborn as sns
from string import ascii_letters
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import IPython
from sklearn.impute import SimpleImputer
from sklearn.decomposition import PCA
from scipy import stats
from statsmodels.stats.outliers_influence import variance_inflation_factor

df_2 = pd.read_excel('/content/drive/MyDrive/gap3.xlsx')

wyfiltrowane2 = df_2[['KRAJE',2016]]
wyfiltrowane2 = wyfiltrowane2.rename(columns={2016: 'różnica'})
print(wyfiltrowane2)

df_3 = pd.read_excel('/content/drive/MyDrive/minimum.xlsx')
wyfiltrowane3 = df_3[['KRAJE',2016]]
wyfiltrowane3 = wyfiltrowane3.rename(columns={2016: 'Minimum'})
print(wyfiltrowane3)

df_4 = pd.read_excel('/content/drive/MyDrive/poverty.xlsx')
wyfiltrowane4 = df_4[['KRAJE',2016]]
wyfiltrowane4 = wyfiltrowane4.rename(columns={2016: 'poverty'})
print(wyfiltrowane4)

df_5 = pd.read_excel('/content/drive/MyDrive/seats.xlsx')
wyfiltrowane5 = df_5[['KRAJE',2016]]
wyfiltrowane5 = wyfiltrowane5.rename(columns={2016: 'emp gap'})
print(wyfiltrowane5)

merged_df = pd.merge(wyfiltrowane2, wyfiltrowane3, on='KRAJE', how='inner')
merged_df = pd.merge(merged_df, wyfiltrowane4, on='KRAJE', how='inner')
merged_df = pd.merge(merged_df, wyfiltrowane5, on='KRAJE', how='inner')

merged_df = merged_df.loc[(merged_df['Minimum'] != ':')]

print(merged_df)

merged_df['różnica'] = pd.to_numeric(merged_df['różnica'], errors='coerce')
merged_df['Minimum'] = pd.to_numeric(merged_df['Minimum'], errors='coerce')
merged_df['poverty'] = pd.to_numeric(merged_df['poverty'], errors='coerce')
merged_df['emp gap'] = pd.to_numeric(merged_df['emp gap'], errors='coerce')

print(merged_df.dtypes)

merged_df_numeric = merged_df.select_dtypes(include=['float64', 'int64'])

dane_kolumny = merged_df['KRAJE']
print(dane_kolumny)

print(merged_df_numeric[merged_df_numeric.isnull().any(axis=1)])

merged_df_numeric.rename(columns={'różnica': 'Gender gap', 'Minimum': 'Płaca minimalna', 'poverty': 'Ryzyko zagrożenia ubóstwem', 'emp gap': 'Różnica osób zatrudnionych'}, inplace=True)

merged_df_numeric.dropna()

merged_df_numeric.dropna()

merged_df_numeric.dropna()

print(merged_df_numeric[merged_df_numeric.isnull().any(axis=1)])

indices_to_drop = [20,21,22,23]
merged_df_numeric.drop(indices_to_drop, inplace=True)

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
import statsmodels.api as sm
from statsmodels.stats.diagnostic import het_breuschpagan
from statsmodels.stats.stattools import durbin_watson


np.random.seed(0)
X = np.random.randn(100, 2)
epsilon = np.random.randn(100) * 2
y = X[:, 0] + X[:, 1] + epsilon

required_columns = ['Płaca minimalna', 'Ryzyko zagrożenia ubóstwem', 'Różnica osób zatrudnionych']
if all(col in merged_df_numeric.columns for col in required_columns):
    X = merged_df_numeric[['Płaca minimalna', 'Ryzyko zagrożenia ubóstwem', 'Różnica osób zatrudnionych']]
    y = merged_df_numeric['Gender gap']


    X_const = sm.add_constant(X)
    model = sm.OLS(y, X_const)
    results = model.fit()


    intercept = results.params[0]
    coefficients = results.params[1:]

    print("Intercept:", intercept)
    print("Coefficients:", coefficients)

    predictions = results.predict(X_const)
    print("Predykcje:", predictions)

    bp_test = het_breuschpagan(results.resid, X_const)
    _, pval_bp, _, _ = bp_test
    print("Wartość p dla testu Breuscha-Pagana:", pval_bp)

    dw = durbin_watson(results.resid)
    print("Wartość testu Durbin-Watsona:", dw)

    new_data = pd.DataFrame({
        'const': [1, 1],
        'Płaca minimalna': [45.0, 40.0],
        'Ryzyko zagrożenia ubóstwem': [20.0, 25.0],
        'Różnica osób zatrudnionych': [5.0, 10.0]
    })
    new_data_const = sm.add_constant(new_data)
    y_pred = results.predict(new_data_const)
    print("Przewidywane wartości y:", y_pred)


    plt.figure(figsize=(12, 6))

    plt.subplot(1, 2, 1)
    plt.plot(merged_df_numeric.index, y, 'o', color='pink', label='Rzeczywiste wartości y')
    plt.plot(merged_df_numeric.index, predictions, color='deepskyblue', linewidth=2, label='Predykcje')
    plt.xlabel('Indeks obserwacji')
    plt.ylabel('Wartości y')
    plt.title('Rzeczywiste wartości vs. Predykcje')
    plt.legend()

    residuals = y - predictions
    plt.subplot(1, 2, 2)
    plt.scatter(predictions, residuals, color='deepskyblue', alpha=0.5)
    plt.axhline(y=0, color='deeppink', linestyle='--')
    plt.xlabel('Predykcje')
    plt.ylabel('Reszty')
    plt.title('Wykres rozproszenia reszt')
    plt.tight_layout()

    plt.show()

else:
    print("Brakuje wymaganych kolumn w DataFrame.")

print(results.summary())

X = merged_df_numeric[['Płaca minimalna', 'Ryzyko zagrożenia ubóstwem', 'Różnica osób zatrudnionych']]
X = sm.add_constant(X)
vif = pd.DataFrame()
vif["Variable"] = X.columns
vif["VIF"] = [variance_inflation_factor(X.values, i) for i in range(X.shape[1])]
print(vif)

#ANALIZA SKUPIEŃ
X = merged_df_numeric[['Gender gap', 'Płaca minimalna', 'Ryzyko zagrożenia ubóstwem', 'Różnica osób zatrudnionych']]  # Wybór kolumn zawierających cechy

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

imputer = SimpleImputer(strategy='mean')
X_scaled_imputed = imputer.fit_transform(X_scaled)

num_clusters = 5

kmeans = KMeans(n_clusters=num_clusters)
kmeans.fit(X_scaled_imputed)
cluster_labels = kmeans.labels_
X['Cluster'] = cluster_labels

cluster_means = X.groupby('Cluster').mean()
print("Średnie wartości dla każdego klastra:")
print(cluster_means)
custom_palette = ['#FFC0CB', '#FF69B4', '#FF1493', '#DB7093', '#C71585']

sns.pairplot(X, hue='Cluster', palette=custom_palette, diag_kind='kde')

plt.suptitle('Klastry', y=1.02)
plt.subplots_adjust(top=0.9, bottom=0.05, left=0.05, right=0.95, hspace=0.2, wspace=0.2)

for ax in plt.gcf().get_axes():
    ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha='right', fontsize=8)
    ax.set_yticklabels(ax.get_yticklabels(), rotation=0, fontsize=8)
plt.tight_layout()
plt.show()

cluster_diff = cluster_means.diff().dropna()
print("\nRóżnice między klastrami:")
print(cluster_diff)

data = {
    'Cluster': [0, 1, 2, 3, 4],
    'Gender gap': [14.9125, 21.65, 6.3667, 11.6, 11.4],
    'Płaca minimalna': [45.5125, 38.375, 47.4667, 45.4, 39.9333],
    'Ryzyko zagrożenia ubóstwem': [25.9375, 17.875, 22.5333, 16.6, 42.0667],
    'Różnica osób zatrudnionych': [7.4125, 10.025, 10.3, 25.5, 12.0]
}

pink_palette = sns.color_palette("ocean", len(cluster_means.columns))

plt.figure(figsize=(10, 6))
cluster_means.plot(kind='bar', color=pink_palette, rot=0)
plt.title('Średnie wartości dla każdego klastra')
plt.xlabel('Klastry')
plt.ylabel('Średnia wartość')
plt.xticks(rotation=45)
plt.legend(title='Zmienne')
plt.tight_layout()
plt.show()

r2 = r2_score(y, predictions)
print("Współczynnik determinacji (R^2):", r2)

r2 = r2_score(y, predictions)
print("Współczynnik determinacji (R²):", r2)

plt.figure(figsize=(10, 6))
sns.scatterplot(x=y, y=predictions, color='black', label='Wartości przewidywane')

plt.plot([min(y), max(y)], [min(y), max(y)], color='pink', linestyle='--', label='Idealne dopasowanie (y=x)')

plt.title(f'Wizualizacja współczynnika determinacji (R² = {r2:.2f})')
plt.xlabel('Rzeczywiste wartości')
plt.ylabel('Przewidywane wartości')
plt.legend()
plt.show()

# Przeprowadzenie testu ANOVA
f_statistic, p_value = f_oneway(merged_df_numeric['Płaca minimalna'], merged_df_numeric['Ryzyko zagrożenia ubóstwem'], merged_df_numeric['Różnica osób zatrudnionych'])

print("Wartość F-statystyki:", f_statistic)
print("Wartość p-wartości:", p_value)

custom_palette = ['#FFC0CB', '#FF69B4', '#FF1493', '#DB7093', '#C71585']
plt.figure(figsize=(12, 8))
sns.violinplot(data=merged_df_numeric, inner='quartile', palette=custom_palette)
plt.title('Wykres skrzypcowy dla zmiennych')
plt.xlabel('Zmienna')
plt.ylabel('Wartość')
plt.xticks(rotation=45, ha='right', fontsize=12)
plt.grid(True)
plt.tight_layout()
plt.show()

#Analiza korelacji

merged_df_numeric = merged_df_numeric.select_dtypes(include=['float64', 'int64'])

correlation_matrix = merged_df_numeric.corr()
print(correlation_matrix)

sns.set_theme(style="white")

correlation_matrix = merged_df_numeric.corr()
mask = np.triu(np.ones_like(correlation_matrix, dtype=bool))

f, ax = plt.subplots(figsize=(11, 9))
cmap = sns.diverging_palette(240, 10, as_cmap=True)

sns.heatmap(correlation_matrix, mask=mask, cmap=cmap, vmax=.3, center=0,
            square=True, linewidths=.5, cbar_kws={"shrink": .5})
ax.set_title("Macierz korelacji", fontsize=16, color='black', fontweight='bold')

# PCA
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

pink_colors = ['#FFB6C1', '#FF69B4', '#FF1493', '#DB7093', '#C71585']

plt.figure(figsize=(8, 6))
scatter = plt.scatter(X_pca[:, 0], X_pca[:, 1], c=cluster_labels, cmap='viridis', alpha=0.8, edgecolors='w', linewidths=0.5)
plt.title('Wizualizacja wyników analizy skupień (PCA)')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')

cbar = plt.colorbar(scatter, ticks=[0, 1, 2, 3, 4])
cbar.set_label('Klaster')
cbar.ax.yaxis.set_tick_params(color='pink')

for i in range(len(cluster_labels)):
    plt.scatter(X_pca[i, 0], X_pca[i, 1], c=pink_colors[cluster_labels[i]], alpha=0.8, edgecolors='w', linewidths=0.5)

plt.grid(True)
plt.show()

plt.hist(residuals, color='pink')
plt.xlabel('Reszty')
plt.ylabel('Liczba obserwacji')
plt.title('Histogram reszt')
plt.show()

shapiro_test = stats.shapiro(residuals)
print('Test Shapiro-Wilka:', shapiro_test)

model = sm.OLS(merged_df_numeric['Gender gap'], X).fit()
residuals = model.resid

plt.figure(figsize=(10, 6))
sns.residplot(x=model.fittedvalues, y=residuals, lowess=True,color='pink')
plt.xlabel('Przewidywane wartości')
plt.ylabel('Reszty')
plt.title('Reszty vs. przewidywane wartości')
plt.show()

plt.figure(figsize=(10, 6))
sns.histplot(residuals, kde=True, color='pink')
plt.xlabel('Reszty')
plt.title('Histogram reszt')
plt.show()

fig = sm.qqplot(residuals, line='s')
plt.title('Wykres Q-Q reszt')
plt.gca().get_lines()[1].set_color('pink')
plt.gca().get_lines()[0].set_markerfacecolor('black')
plt.show()



"""PODSTAWOWE ANALIZY"""

średnia_lata = df_2.iloc[:, 1:]
średnia_lata = średnia_lata.apply(pd.to_numeric, errors='coerce')
średnia_lata = średnia_lata.mean(axis=0,skipna=True)
mean_df2 = średnia_lata
print(mean_df2)

sns.set(style="white")
plt.figure(figsize=(10, 6))
sns.set_style("whitegrid", {'axes.facecolor': 'white'})
plt.plot(mean_df2.index,mean_df2.values, marker='o', linestyle='-',color="black")


plt.xlabel('Rok')
plt.ylabel('Średnia różnica w zarobkach')
plt.title('Gender gap')

plt.grid(True)
plt.show()

średnia_lata = df_3.iloc[:, 1:]
średnia_lata = średnia_lata.apply(pd.to_numeric, errors='coerce')
średnia_lata = średnia_lata.mean(axis=0,skipna=True)
mean_df3 = średnia_lata
print(mean_df3)

sns.set(style="white")
plt.figure(figsize=(10, 6))
sns.set_style("whitegrid", {'axes.facecolor': 'white'})
plt.plot(mean_df3.index,mean_df3.values, marker='o', linestyle='-',color="black")
plt.xlabel('Rok')
plt.ylabel('Średnia płaca minimalna')
plt.title('Płaca minimalna')

plt.grid(True)
plt.show()

średnia_lata = df_4.iloc[:, 1:]
średnia_lata = średnia_lata.apply(pd.to_numeric, errors='coerce')
średnia_lata = średnia_lata.mean(axis=0,skipna=True)
mean_df4 = średnia_lata
print(mean_df4)

sns.set(style="white")
plt.figure(figsize=(10, 6))
sns.set_style("whitegrid", {'axes.facecolor': 'white'})
plt.plot(mean_df4.index,mean_df4.values, marker='o', linestyle='-',color="black")
plt.xlabel('Rok')
plt.ylabel('Średnia wartość ubóstwa')
plt.title('Ryzyko zagrożenia ubóstwem')

plt.grid(True)
plt.show()

średnia_lata = df_5.iloc[:, 1:]
średnia_lata = średnia_lata.apply(pd.to_numeric, errors='coerce')
średnia_lata = średnia_lata.mean(axis=0,skipna=True)
mean_df5 = średnia_lata
print(mean_df5)

sns.set(style="white")
plt.figure(figsize=(10, 6))
sns.set_style("whitegrid", {'axes.facecolor': 'white'})
plt.plot(mean_df3.index,mean_df3.values, marker='o', linestyle='-',color="black")
plt.xlabel('Rok')
plt.ylabel('Różnica w liczbie osób zatrudnionych')
plt.title('Różnica w liczbie osób zatrudnionych')
plt.grid(True)
plt.show()

mediana_lata = df_2.iloc[:, 1:]
mediana_lata = mediana_lata.apply(pd.to_numeric, errors='coerce')
mediana_lata = mediana_lata.median(axis=0,skipna=True)
median_df2 = mediana_lata
print(median_df2)

sns.set(style="white")
plt.figure(figsize=(10, 6))
sns.set_style("whitegrid", {'axes.facecolor': 'white'})
plt.plot(median_df2.index,median_df2.values, marker='o', linestyle='-',color="red")
plt.xlabel('Rok')
plt.ylabel('Mediana')
plt.title('Gender gap')
plt.grid(True)
plt.show()

from matplotlib.ticker import MaxNLocator
mediana_lata = df_3.iloc[:, 1:]
mediana_lata = mediana_lata.apply(pd.to_numeric, errors='coerce')
mediana_lata = mediana_lata.median(axis=0, skipna=True)
median_df3 = mediana_lata

print(median_df3)

sns.set(style="white")
plt.figure(figsize=(10, 6))
sns.set_style("whitegrid", {'axes.facecolor': 'white'})
plt.plot(median_df3.index, median_df3.values, marker='o', linestyle='-', color="red")
plt.xlabel('Rok')
plt.ylabel('Mediana')
plt.title('Różnica w liczbie osób zatrudnionych')

plt.gca().xaxis.set_major_locator(MaxNLocator(integer=True))

plt.grid(True)
plt.show()

mediana_lata = df_4.iloc[:, 1:]
mediana_lata = mediana_lata.apply(pd.to_numeric, errors='coerce')
mediana_lata = mediana_lata.median(axis=0,skipna=True)
median_df4 = mediana_lata
print(median_df4)

sns.set(style="white")
plt.figure(figsize=(10, 6))
sns.set_style("whitegrid", {'axes.facecolor': 'white'})
plt.plot(median_df4.index,median_df4.values, marker='o', linestyle='-',color="red")
plt.xlabel('Rok')
plt.ylabel('Mediana')
plt.title('Ryzyko zagrożenia ubóstwem')
plt.grid(True)
plt.show()

from matplotlib.ticker import MaxNLocator
mediana_lata = df_5.iloc[:, 1:]
mediana_lata = mediana_lata.apply(pd.to_numeric, errors='coerce')
mediana_lata = mediana_lata.median(axis=0, skipna=True)
median_df5 = mediana_lata

print(median_df5)

sns.set(style="white")
plt.figure(figsize=(10, 6))
sns.set_style("whitegrid", {'axes.facecolor': 'white'})
plt.plot(median_df5.index, median_df5.values, marker='o', linestyle='-', color="red")
plt.xlabel('Rok')
plt.ylabel('Mediana')
plt.title('Różnica w liczbie osób zatrudnionych')


plt.gca().xaxis.set_major_locator(MaxNLocator(integer=True))

plt.grid(True)
plt.show()
